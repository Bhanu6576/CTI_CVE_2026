const fetch = require('node-fetch');

/**
 * Helper function to pause execution for a set time
 * @param {number} ms - Milliseconds to sleep
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Search for CVEs with CVSS score >= 8.0 from NVD API
 * @param {string} apiKey - Optional NVD API key for better rate limits
 * @param {number} cvssThreshold - Minimum CVSS score (default 8.0)
 * @returns {Promise<Array>} Array of CVE objects
 */
async function searchCVEs(apiKey = null, cvssThreshold = 8.0) {
  try {
    // Validate inputs
    if (cvssThreshold !== null && cvssThreshold !== undefined) {
      const threshold = parseFloat(cvssThreshold);
      if (isNaN(threshold) || threshold < 0 || threshold > 10) {
        throw new Error('CVSS threshold must be a number between 0 and 10');
      }
      cvssThreshold = threshold;
    } else {
      cvssThreshold = 8.0;
    }
    
    if (apiKey !== null && typeof apiKey !== 'string') {
      throw new Error('API key must be a string');
    }
    // Get CVEs from the last 7 days
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    const pubStartDate = sevenDaysAgo.toISOString().split('T')[0] + 'T00:00:00.000';
    const pubEndDate = now.toISOString().split('T')[0] + 'T23:59:59.999';
    
    const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=${pubStartDate}&pubEndDate=${pubEndDate}`;
    
    const headers = {
      'User-Agent': 'CVE-Automation-Tool/1.0'
    };
    
    if (apiKey) {
      headers['apiKey'] = apiKey;
    }
    
    console.log(`Searching CVEs from ${pubStartDate} to ${pubEndDate}...`);
    
    // --- RETRY LOGIC START ---
    let response;
    let attempts = 0;
    const maxRetries = 3;
    const baseDelay = 3000; // Start with 3 seconds

    while (attempts < maxRetries) {
      try {
        // Add timeout to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
        
        response = await fetch(url, { 
          headers,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        // If successful, break the loop
        if (response.ok) {
          break;
        }

        // Handle specific NVD rate limits (403/429) or server errors (503/504)
        if (response.status === 429 || response.status === 503 || response.status === 504) {
            const delay = baseDelay * (attempts + 1); // Linear backoff: 3s, 6s, 9s
            console.warn(`NVD API returned status ${response.status}. Retrying in ${delay/1000} seconds... (Attempt ${attempts + 1}/${maxRetries})`);
            await sleep(delay);
            attempts++;
        } else {
            // For other errors (404, 401, etc), throw immediately
            throw new Error(`NVD API returned fatal status ${response.status}`);
        }
      } catch (networkError) {
        // Handle network level errors (DNS, socket hang up, etc.)
        if (attempts === maxRetries - 1) {
          // Log detailed error internally but throw sanitized error
          console.error(`Network error details: ${networkError.message}`);
          throw new Error('Failed to connect to NVD API after multiple attempts');
        }
        
        const delay = baseDelay * (attempts + 1);
        console.warn(`Network error occurred. Retrying in ${delay/1000} seconds...`);
        await sleep(delay);
        attempts++;
      }
    }
    // --- RETRY LOGIC END ---
    
    // Final check if response is valid after retries
    if (!response || !response.ok) {
      throw new Error(`Failed to fetch from NVD after ${maxRetries} attempts. Final status: ${response ? response.status : 'Unknown'}`);
    }
    
    const data = await response.json();
    
    if (!data.vulnerabilities || data.vulnerabilities.length === 0) {
      console.log('No CVEs found in the specified time range');
      return [];
    }
    
    // Filter CVEs by CVSS score and format them
    const highSeverityCVEs = data.vulnerabilities
      .map(vuln => {
        const cve = vuln.cve;
        const cveId = cve.id;
        
        // Extract CVSS scores
        let cvssScore = 0;
        let cvssVector = '';
        let severity = 'UNKNOWN';
        
        // Try to get CVSS v3.x score first
        if (cve.metrics?.cvssMetricV31 && cve.metrics.cvssMetricV31.length > 0) {
          const metric = cve.metrics.cvssMetricV31[0];
          cvssScore = metric.cvssData.baseScore;
          cvssVector = metric.cvssData.vectorString;
          severity = metric.cvssData.baseSeverity;
        } else if (cve.metrics?.cvssMetricV30 && cve.metrics.cvssMetricV30.length > 0) {
          const metric = cve.metrics.cvssMetricV30[0];
          cvssScore = metric.cvssData.baseScore;
          cvssVector = metric.cvssData.vectorString;
          severity = metric.cvssData.baseSeverity;
        } else if (cve.metrics?.cvssMetricV2 && cve.metrics.cvssMetricV2.length > 0) {
          const metric = cve.metrics.cvssMetricV2[0];
          cvssScore = metric.cvssData.baseScore;
          cvssVector = metric.cvssData.vectorString;
          severity = metric.baseSeverity || 'UNKNOWN';
        }
        
        // Get description
        const description = cve.descriptions?.find(d => d.lang === 'en')?.value || 'No description available';
        
        // Get references
        const references = cve.references?.map(ref => ref.url) || [];
        
        // Get published date
        const publishedDate = cve.published || '';
        
        return {
          id: cveId,
          cvssScore,
          cvssVector,
          severity,
          description,
          references,
          publishedDate,
          url: `https://nvd.nist.gov/vuln/detail/${cveId}`
        };
      })
      .filter(cve => cve.cvssScore >= cvssThreshold)
      .sort((a, b) => b.cvssScore - a.cvssScore);
    
    console.log(`Found ${highSeverityCVEs.length} CVEs with CVSS >= ${cvssThreshold}`);
    
    return highSeverityCVEs;
  } catch (error) {
    console.error('Error searching CVEs:', error.message);
    throw error;
  }
}

module.exports = { searchCVEs };
